% This function allocates every pixel in an image to a cluster, based on a
% set of random pixels ('seedMeans') selected in another function based on
% the user input value 'k'. This means that the 'seedMeans' values are
% randomly assigned, and then the entire remainder of the pixel values of
% the image are assigned to a cluster based on how close they are to each
% 'seedMean'. For example, if you had 3 seedMeans, then you would have 3
% clusters of colour values based on the squared distance between the
% points.
% Inputs: A: A 3D image or array in the double format.
%         seedMeans: A 3D array of rgb values with one column & 3 layers.
%         This can be generated by 'GetRGBValuesForPoints'
% Output: clusters: A 2D array the same height and width as A with each
%         pixel assigned a cluster number based on the size and value of 
%         seedMeans.
% Author: Alex Verkerk

function [clusters] = AssignToClusters(A,seedMeans)
clusters=zeros(size(A,1),size(A,2)); % Preallocating clusters array.
% Preallocating kclusters array. This array essentially stores every
% distance value for a pixel in the 3rd dimension. Eg. if there are 5
% seedMeans, then there will be 5 layers for each pixel, containing the
% distance of the pixel from each of the means.
kclusters=zeros(size(A,1),size(A,2),size(seedMeans,1));

% This for loop cycles through all the values of the seedMeans and finds
% the squaredDistance between the point and the seedMean. The formula used
% for the squared distance between points is:
% D=(P(1)-Q(1))^2 + (P(2)-Q(2))^2 + (P(3)-Q(3))^2
% This for loop uses vectorisation to complete the operation of the
% squaredDistance formula more efficiently.
for i=1:size(seedMeans,1)
    kclusters(:,:,i)=(A(:,:,1)-seedMeans(i,:,1)).^2 + (A(:,:,2)...
        -seedMeans(i,:,2)).^2 + (A(:,:,3)-seedMeans(i,:,3)).^2;
end
% This for loop cycles through each element in the layers of our kclusters 
% array (ie where the distance from the seedMeans values were stored) and
% finds the smallest distance. As a result of how the find function works,
% this will return the layer number of the smallest distance, which we 
% assign as the cluster number. This was partially inspired by a reply to
% this post on mathworks: 
% https://au.mathworks.com/matlabcentral/answers/13149-finding-duplicates
for ii=1:size(A,1)
    for jj=1:size(A,2)
        temppoints=find(kclusters(ii,jj,:)==min(kclusters(ii,jj,:)));
        % This if statment fixes an error that occurs when there are two or
        % more minimum distances, and selects the first of the minimum
        % distances if there are multiple. If there is only one minimum
        % distance found, it is added to the clusters array.
        if length(temppoints)>1
            clusters(ii,jj)=temppoints(1,1);
        else
            clusters(ii,jj)=temppoints;
        end
    end
end
end